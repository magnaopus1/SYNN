package consensus_automations

import (
    "fmt"
    "sync"
    "time"
    "synnergy_network/pkg/common"
    "synnergy_network/pkg/encryption"
    "synnergy_network/pkg/ledger"
    "synnergy_network/pkg/consensus"
)

const (
    IntegrityCheckInterval   = 3 * time.Minute       // Interval for integrity checks
    IntegrityResolutionKey   = "integrity_resolution_key" // Encryption key for sensitive data in integrity checks
)

// ConsensusIntegrityMonitoringAutomation handles the continuous monitoring of the integrity of the Synnergy Consensus process
type ConsensusIntegrityMonitoringAutomation struct {
    ledgerInstance  *ledger.Ledger                     // Blockchain ledger for tracking consensus actions
    consensusEngine *consensus.SynnergyConsensus // Synnergy Consensus engine for validation
    stateMutex      *sync.RWMutex                      // Mutex for thread-safe ledger access
}

// NewConsensusIntegrityMonitoringAutomation initializes the automation for monitoring the integrity of the Synnergy Consensus process
func NewConsensusIntegrityMonitoringAutomation(consensusEngine *consensus.SynnergyConsensus, ledgerInstance *ledger.Ledger, stateMutex *sync.RWMutex) *ConsensusIntegrityMonitoringAutomation {
    return &ConsensusIntegrityMonitoringAutomation{
        ledgerInstance:  ledgerInstance,
        consensusEngine: consensusEngine,
        stateMutex:      stateMutex,
    }
}

// StartIntegrityMonitoring initiates continuous monitoring of the Synnergy Consensus process
func (automation *ConsensusIntegrityMonitoringAutomation) StartIntegrityMonitoring() {
    ticker := time.NewTicker(IntegrityCheckInterval)
    for range ticker.C {
        fmt.Println("Checking integrity of the Synnergy Consensus process...")
        automation.monitorConsensusIntegrity()
    }
}

// monitorConsensusIntegrity checks the overall integrity of the consensus process using PoH, PoS, and PoW
func (automation *ConsensusIntegrityMonitoringAutomation) monitorConsensusIntegrity() {
    pohValid := automation.validatePoH()
    posValid := automation.validatePoS()
    powValid := automation.validatePoW()

    if pohValid && posValid && powValid {
        fmt.Println("Consensus integrity is intact.")
    } else {
        fmt.Println("Consensus integrity issues detected.")
        automation.resolveIntegrityIssues()
    }
}

// validatePoH verifies PoH proofs to ensure historical sequencing accuracy
func (automation *ConsensusIntegrityMonitoringAutomation) validatePoH() bool {
    success := automation.consensusEngine.PoH.ValidatePoHProof()
    if !success {
        fmt.Println("PoH validation failed.")
        return false
    }
    fmt.Println("PoH validation successful.")
    return true
}

// validatePoS checks if PoS validators hold the required stake for validation
func (automation *ConsensusIntegrityMonitoringAutomation) validatePoS() bool {
    validator := automation.consensusEngine.PoS.SelectValidator()
    if validator == nil {
        fmt.Println("PoS validator stake validation failed.")
        return false
    }

    success := automation.consensusEngine.PoS.ValidateSubBlock(validator)
    if !success {
        fmt.Println("PoS validator stake validation failed.")
        return false
    }
    fmt.Println("PoS validator stake validation successful.")
    return true
}

// validatePoW ensures that the final blocks generated by PoW are correct
func (automation *ConsensusIntegrityMonitoringAutomation) validatePoW() bool {
    success := automation.consensusEngine.PoW.ValidateBlock()
    if !success {
        fmt.Println("PoW block validation failed.")
        return false
    }
    fmt.Println("PoW block validation successful.")
    return true
}

// resolveIntegrityIssues resolves any detected issues with consensus integrity
func (automation *ConsensusIntegrityMonitoringAutomation) resolveIntegrityIssues() {
    fmt.Println("Resolving consensus integrity issues...")

    // Process transactions to ensure proper integrity
    automation.processTransactionsForIntegrity()

    // Revalidate the full chain integrity
    automation.validateFullChain()

    // Log the integrity resolution in the ledger
    automation.logIntegrityResolution()
}

// processTransactionsForIntegrity handles processing transactions as part of integrity resolution
func (automation *ConsensusIntegrityMonitoringAutomation) processTransactionsForIntegrity() {
    success := automation.consensusEngine.ProcessTransactions()
    if !success {
        fmt.Println("Error processing transactions for integrity resolution.")
        return
    }
    fmt.Println("Transactions processed successfully for integrity resolution.")
}

// validateFullChain validates the entire chain as part of integrity resolution
func (automation *ConsensusIntegrityMonitoringAutomation) validateFullChain() {
    success := automation.consensusEngine.ValidateChain()
    if !success {
        fmt.Println("Error validating full chain during integrity resolution.")
        return
    }
    fmt.Println("Full chain validation successful for integrity resolution.")
}

// logIntegrityResolution logs the integrity resolution event in the blockchain ledger for auditing
func (automation *ConsensusIntegrityMonitoringAutomation) logIntegrityResolution() {
    automation.stateMutex.Lock()
    defer automation.stateMutex.Unlock()

    entry := common.LedgerEntry{
        ID:        fmt.Sprintf("integrity-resolution-%d", time.Now().Unix()),
        Timestamp: time.Now().Unix(),
        Type:      "Integrity Resolution",
        Status:    "Resolved",
    }

    // Encrypt the ledger entry for security purposes
    encryptedEntry, err := encryption.EncryptLedgerEntry(entry, []byte(IntegrityResolutionKey))
    if err != nil {
        fmt.Printf("Error encrypting ledger entry for integrity resolution: %v\n", err)
        return
    }

    automation.consensusEngine.ValidateSubBlock(entry) // Validate integrity resolution as a sub-block
    automation.ledgerInstance.AddEntry(encryptedEntry)
    fmt.Printf("Ledger updated with integrity resolution event.\n")
}

// Additional helper function to ensure chain and ledger consistency post-integrity resolution
func (automation *ConsensusIntegrityMonitoringAutomation) ensureChainAndLedgerConsistency() {
    fmt.Println("Ensuring chain and ledger consistency post-integrity resolution...")

    automation.stateMutex.Lock()
    defer automation.stateMutex.Unlock()

    // Validate the chain and sub-blocks for consistency
    err := automation.consensusEngine.ValidateChain()
    if err != nil {
        fmt.Printf("Chain validation failed: %v\n", err)
        automation.resolveIntegrityIssues() // Trigger integrity resolution again if consistency is not restored
    } else {
        fmt.Println("Ledger and chain are consistent after integrity resolution.")
    }
}
