package execution_automations

import (
	"fmt"
	"sync"
	"time"
	"synnergy_network_demo/common"
	"synnergy_network_demo/encryption"
	"synnergy_network_demo/ledger"
	"synnergy_network_demo/smart_contracts"
	"synnergy_network_demo/synnergy_consensus"
)

const (
	VulnerabilityCheckInterval          = 30 * time.Minute // Interval for checking smart contract vulnerabilities
	VulnerabilityPatchLedgerType        = "Vulnerability Patch"
)

// SmartContractVulnerabilityPatchAutomation manages the detection and patching of vulnerabilities in smart contracts
type SmartContractVulnerabilityPatchAutomation struct {
	consensusEngine   *synnergy_consensus.SynnergyConsensus   // Consensus engine for validation
	ledgerInstance    *ledger.Ledger                         // Ledger instance for logging patch events
	smartContractManager *smart_contracts.Manager             // Manager for handling smart contracts
	executionMutex    *sync.RWMutex                          // Mutex for thread-safe operations
}

// NewSmartContractVulnerabilityPatchAutomation initializes the automation for patching smart contract vulnerabilities
func NewSmartContractVulnerabilityPatchAutomation(consensusEngine *synnergy_consensus.SynnergyConsensus, ledgerInstance *ledger.Ledger, smartContractManager *smart_contracts.Manager, executionMutex *sync.RWMutex) *SmartContractVulnerabilityPatchAutomation {
	return &SmartContractVulnerabilityPatchAutomation{
		consensusEngine:   consensusEngine,
		ledgerInstance:    ledgerInstance,
		smartContractManager: smartContractManager,
		executionMutex:    executionMutex,
	}
}

// StartVulnerabilityPatchMonitor begins continuous monitoring for smart contract vulnerabilities
func (automation *SmartContractVulnerabilityPatchAutomation) StartVulnerabilityPatchMonitor() {
	ticker := time.NewTicker(VulnerabilityCheckInterval)

	go func() {
		for range ticker.C {
			automation.checkForVulnerabilitiesAndPatch()
		}
	}()
}

// checkForVulnerabilitiesAndPatch checks smart contracts for vulnerabilities and applies patches if necessary
func (automation *SmartContractVulnerabilityPatchAutomation) checkForVulnerabilitiesAndPatch() {
	automation.executionMutex.Lock()
	defer automation.executionMutex.Unlock()

	vulnerableContracts := automation.smartContractManager.GetVulnerableContracts()

	for _, contract := range vulnerableContracts {
		automation.validateAndPatchContract(contract)
	}
}

// validateAndPatchContract validates the identified vulnerability via the Synnergy Consensus and applies the patch
func (automation *SmartContractVulnerabilityPatchAutomation) validateAndPatchContract(contract *smart_contracts.SmartContract) {
	// Validate the patch proposal using the Synnergy Consensus engine
	valid, err := automation.consensusEngine.ValidateContractPatch(contract)
	if err != nil {
		fmt.Printf("Failed to validate patch for contract %s: %v\n", contract.ID, err)
		return
	}

	if !valid {
		fmt.Printf("Patch validation for smart contract %s failed.\n", contract.ID)
		automation.logPatchFailure(contract, "Patch validation failed")
		return
	}

	// Apply the vulnerability patch
	err = automation.smartContractManager.ApplyPatch(contract)
	if err != nil {
		fmt.Printf("Failed to apply patch for contract %s: %v\n", contract.ID, err)
		automation.logPatchFailure(contract, "Patch application failed")
		return
	}

	// Log successful patch application in the ledger
	automation.logPatchSuccess(contract)
}

// logPatchSuccess logs the successful application of a patch in the ledger
func (automation *SmartContractVulnerabilityPatchAutomation) logPatchSuccess(contract *smart_contracts.SmartContract) {
	entry := common.LedgerEntry{
		ID:        fmt.Sprintf("vulnerability-patch-success-%s-%d", contract.ID, time.Now().Unix()),
		Timestamp: time.Now().Unix(),
		Type:      VulnerabilityPatchLedgerType,
		Status:    "Success",
		Details:   fmt.Sprintf("Patch for smart contract %s successfully applied.", contract.ID),
	}

	encryptedDetails := automation.encryptData(entry.Details)
	entry.Details = encryptedDetails

	err := automation.ledgerInstance.AddEntry(entry)
	if err != nil {
		fmt.Printf("Failed to log successful patch application for contract %s: %v\n", contract.ID, err)
	} else {
		fmt.Println("Patch application successfully logged in the ledger.")
	}
}

// logPatchFailure logs a failure event when a patch fails validation or application
func (automation *SmartContractVulnerabilityPatchAutomation) logPatchFailure(contract *smart_contracts.SmartContract, reason string) {
	entry := common.LedgerEntry{
		ID:        fmt.Sprintf("vulnerability-patch-failure-%s-%d", contract.ID, time.Now().Unix()),
		Timestamp: time.Now().Unix(),
		Type:      VulnerabilityPatchLedgerType,
		Status:    "Failure",
		Details:   fmt.Sprintf("Patch for smart contract %s failed: %s", contract.ID, reason),
	}

	encryptedDetails := automation.encryptData(entry.Details)
	entry.Details = encryptedDetails

	err := automation.ledgerInstance.AddEntry(entry)
	if err != nil {
		fmt.Printf("Failed to log patch failure for contract %s: %v\n", contract.ID, err)
	} else {
		fmt.Println("Patch failure logged in the ledger.")
	}
}

// encryptData encrypts sensitive data before logging it into the ledger
func (automation *SmartContractVulnerabilityPatchAutomation) encryptData(data string) string {
	encryptedData, err := encryption.EncryptData([]byte(data))
	if err != nil {
		fmt.Println("Error encrypting data:", err)
		return data
	}
	return string(encryptedData)
}

// TriggerManualVulnerabilityPatch allows administrators to manually trigger a vulnerability patch
func (automation *SmartContractVulnerabilityPatchAutomation) TriggerManualVulnerabilityPatch(contractID string) {
	fmt.Printf("Manually triggering vulnerability patch for smart contract %s...\n", contractID)

	contract := automation.smartContractManager.GetContractByID(contractID)
	if contract != nil {
		automation.validateAndPatchContract(contract)
	} else {
		fmt.Printf("Smart contract %s not found.\n", contractID)
	}
}
