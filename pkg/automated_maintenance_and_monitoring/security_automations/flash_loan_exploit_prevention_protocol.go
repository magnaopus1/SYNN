package security_automations

import (
    "fmt"
    "sync"
    "time"
    "synnergy_network_demo/common"
    "synnergy_network_demo/ledger"
    "synnergy_network_demo/consensus"
    "synnergy_network_demo/encryption"
)

const (
    FlashLoanMonitoringInterval = 10 * time.Second // Interval to monitor flash loan activity
    MaxFlashLoanAttemptThreshold = 5               // Max number of flash loan attempts before triggering prevention
)

// FlashLoanExploitPreventionAutomation ensures that flash loan exploits are detected and prevented
type FlashLoanExploitPreventionAutomation struct {
    consensusSystem    *consensus.SynnergyConsensus // Reference to SynnergyConsensus struct
    ledgerInstance     *ledger.Ledger               // Ledger for logging flash loan activities
    stateMutex         *sync.RWMutex                // Mutex for thread-safe access
    loanAttemptTracker map[string]int               // Tracks flash loan attempts per wallet/contract
}

// NewFlashLoanExploitPreventionAutomation initializes the flash loan exploit prevention automation
func NewFlashLoanExploitPreventionAutomation(consensusSystem *consensus.SynnergyConsensus, ledgerInstance *ledger.Ledger, stateMutex *sync.RWMutex) *FlashLoanExploitPreventionAutomation {
    return &FlashLoanExploitPreventionAutomation{
        consensusSystem:    consensusSystem,
        ledgerInstance:     ledgerInstance,
        stateMutex:         stateMutex,
        loanAttemptTracker: make(map[string]int),
    }
}

// StartFlashLoanMonitoring starts the continuous monitoring for flash loan exploits
func (automation *FlashLoanExploitPreventionAutomation) StartFlashLoanMonitoring() {
    ticker := time.NewTicker(FlashLoanMonitoringInterval)

    go func() {
        for range ticker.C {
            automation.monitorFlashLoanActivity()
        }
    }()
}

// monitorFlashLoanActivity monitors all flash loans and prevents exploits
func (automation *FlashLoanExploitPreventionAutomation) monitorFlashLoanActivity() {
    automation.stateMutex.Lock()
    defer automation.stateMutex.Unlock()

    flashLoanList := automation.consensusSystem.GetPendingFlashLoans()

    if len(flashLoanList) > 0 {
        for _, flashLoan := range flashLoanList {
            automation.handleFlashLoan(flashLoan)
        }
    } else {
        fmt.Println("No flash loan activity detected.")
    }
}

// handleFlashLoan handles the prevention logic for flash loan activity
func (automation *FlashLoanExploitPreventionAutomation) handleFlashLoan(flashLoan common.FlashLoanTransaction) {
    encryptedLoanData := automation.encryptFlashLoanData(flashLoan)
    
    if automation.isExploitDetected(flashLoan) {
        automation.preventFlashLoan(flashLoan)
        automation.logFlashLoanExploit(flashLoan)
    } else {
        automation.approveFlashLoan(flashLoan, encryptedLoanData)
    }
}

// isExploitDetected checks if a flash loan exploit pattern is detected
func (automation *FlashLoanExploitPreventionAutomation) isExploitDetected(flashLoan common.FlashLoanTransaction) bool {
    automation.loanAttemptTracker[flashLoan.WalletID]++
    
    if automation.loanAttemptTracker[flashLoan.WalletID] > MaxFlashLoanAttemptThreshold {
        fmt.Printf("Flash loan exploit detected for wallet %s. Attempts: %d\n", flashLoan.WalletID, automation.loanAttemptTracker[flashLoan.WalletID])
        return true
    }
    return false
}

// preventFlashLoan triggers the prevention of a flash loan transaction
func (automation *FlashLoanExploitPreventionAutomation) preventFlashLoan(flashLoan common.FlashLoanTransaction) {
    fmt.Printf("Flash loan prevention triggered for wallet %s.\n", flashLoan.WalletID)
    automation.consensusSystem.BlockFlashLoan(flashLoan)
}

// approveFlashLoan approves the flash loan transaction if no exploit is detected
func (automation *FlashLoanExploitPreventionAutomation) approveFlashLoan(flashLoan common.FlashLoanTransaction, encryptedLoanData []byte) {
    automation.consensusSystem.ApproveFlashLoan(flashLoan, encryptedLoanData)
    fmt.Printf("Flash loan approved for wallet %s.\n", flashLoan.WalletID)
    automation.resetFlashLoanAttempts(flashLoan.WalletID)
}

// logFlashLoanExploit logs the flash loan exploit attempt in the ledger
func (automation *FlashLoanExploitPreventionAutomation) logFlashLoanExploit(flashLoan common.FlashLoanTransaction) {
    entry := common.LedgerEntry{
        ID:        fmt.Sprintf("flash-loan-exploit-%s", flashLoan.WalletID),
        Timestamp: time.Now().Unix(),
        Type:      "Flash Loan Exploit",
        Status:    "Blocked",
        Details:   fmt.Sprintf("Flash loan exploit detected and blocked for wallet %s.", flashLoan.WalletID),
    }
    automation.ledgerInstance.AddEntry(entry)
    fmt.Printf("Ledger updated with flash loan exploit for wallet %s.\n", flashLoan.WalletID)
}

// resetFlashLoanAttempts resets the flash loan attempt counter for a wallet
func (automation *FlashLoanExploitPreventionAutomation) resetFlashLoanAttempts(walletID string) {
    automation.loanAttemptTracker[walletID] = 0
}

// encryptFlashLoanData encrypts the flash loan data before approval
func (automation *FlashLoanExploitPreventionAutomation) encryptFlashLoanData(flashLoan common.FlashLoanTransaction) []byte {
    encryptedData, err := encryption.EncryptData(flashLoan.Data)
    if err != nil {
        fmt.Printf("Error encrypting flash loan data for wallet %s: %s\n", flashLoan.WalletID, err)
        return nil
    }
    fmt.Printf("Flash loan data encrypted for wallet %s.\n", flashLoan.WalletID)
    return encryptedData
}
