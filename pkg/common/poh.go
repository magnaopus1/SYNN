package common

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"synnergy_network/pkg/ledger"
	"time"
)

// PoH represents the Proof of History mechanism, now integrated with the Reward Manager and Ledger
type PoH struct {
	State          PoHState        // The current state of the PoH system
	LedgerInstance *ledger.Ledger  // Ledger to store PoH proofs
	RewardManager  *RewardManager  // Reward manager for rewarding validators
}

// PoHState represents the state of the Proof of History (PoH) mechanism
type PoHState struct {
	Sequence      int       // The current sequence number in PoH
	LastTimestamp time.Time // Timestamp of the last PoH entry
	LastHash      string    // Hash of the previous PoH entry
}

// PoHProof represents the proof generated by PoH
type PoHProof struct {
	Sequence  int       // The sequence number for this proof
	Timestamp time.Time // The timestamp for this PoH proof
	Hash      string    // Hash generated by PoH for this entry
}

// NewPoH initializes a new PoH system and integrates it with the ledger and reward manager
func NewPoH(ledgerInstance *ledger.Ledger, rewardManager *RewardManager) *PoH {
    return &PoH{
        State: PoHState{
            Sequence:      0,
            LastTimestamp: time.Now(),
            LastHash:      "genesis_hash", // Start with a default genesis hash
        },
        LedgerInstance: ledgerInstance,
        RewardManager:  rewardManager,
    }
}

// GeneratePoHProof generates a new PoH proof by hashing the previous hash, current time, and sorted transaction metadata.
func (p *PoH) GeneratePoHProof(transactions []Transaction) (PoHProof, error) {
    currentTime := time.Now()

    // Validate transactions input
    if len(transactions) == 0 {
        return PoHProof{}, fmt.Errorf("no transactions provided for PoH proof generation")
    }

    // Step 1: Sort transactions deterministically
    sortedTransactions, err := sortTransactions(transactions)
    if err != nil {
        return PoHProof{}, fmt.Errorf("failed to sort transactions: %w", err)
    }

    transactionHashes, err := extractTransactionHashes(sortedTransactions)
    if err != nil {
        return PoHProof{}, fmt.Errorf("failed to extract transaction hashes: %w", err)
    }

    transactionsHash, err := computeAggregateHash(transactionHashes)
    if err != nil {
        return PoHProof{}, fmt.Errorf("failed to compute aggregate hash: %w", err)
    }

    // Step 2: Combine the previous hash, current timestamp, and transaction hash for the new proof
    input := fmt.Sprintf("%s%d%s", p.State.LastHash, currentTime.UnixNano(), transactionsHash)
    hash := sha256.New()
    _, writeErr := hash.Write([]byte(input))
    if writeErr != nil {
        return PoHProof{}, fmt.Errorf("hash write error: %w", writeErr)
    }
    newHash := hex.EncodeToString(hash.Sum(nil))

    // Step 3: Create the PoH proof
    proof := PoHProof{
        Sequence:  p.State.Sequence + 1,
        Timestamp: currentTime,
        Hash:      newHash,
    }

    // Step 4: Store the proof in the ledger with concurrency control
    ledgerPoHProof := ledger.PoHProof{
        Sequence:  proof.Sequence,
        Timestamp: proof.Timestamp,
        Hash:      proof.Hash,
    }

    p.LedgerInstance.Mutex.Lock()
    defer p.LedgerInstance.Mutex.Unlock()

    if err := p.LedgerInstance.BlockchainConsensusCoinLedger.AddPoHProof(ledgerPoHProof); err != nil {
        return PoHProof{}, fmt.Errorf("failed to store PoH proof in ledger: %w", err)
    }

    // Step 5: Log the successful proof generation
    log.Printf("[Info] PoH proof generated: Sequence=%d, Timestamp=%s, Hash=%s\n", 
        proof.Sequence, proof.Timestamp.Format(time.RFC3339), proof.Hash)

    // Step 6: Update internal PoH state
    p.State.Sequence = proof.Sequence
    p.State.LastTimestamp = currentTime
    p.State.LastHash = proof.Hash

    return proof, nil
}


// ValidatePoHProof validates that a PoH proof is part of the correct sequence and validates the transactions it covers.
func (p *PoH) ValidatePoHProof(proof PoHProof, transactions []Transaction) (bool, error) {
    if proof.Sequence <= 0 {
        return false, fmt.Errorf("invalid PoH proof: sequence number must be greater than 0")
    }

    // Validate timestamp
    if proof.Timestamp.Before(p.State.LastTimestamp) {
        return false, fmt.Errorf("invalid PoH proof: timestamp is earlier than the last recorded timestamp")
    }

    // Step 1: Sort transactions deterministically
    sortedTransactions, err := sortTransactions(transactions)
    if err != nil {
        return false, fmt.Errorf("failed to sort transactions: %w", err)
    }

    transactionHashes, err := extractTransactionHashes(sortedTransactions)
    if err != nil {
        return false, fmt.Errorf("failed to extract transaction hashes: %w", err)
    }

    transactionsHash, err := computeAggregateHash(transactionHashes)
    if err != nil {
        return false, fmt.Errorf("failed to compute aggregate hash: %w", err)
    }

    // Step 2: Recalculate the expected hash for the proof
    input := fmt.Sprintf("%s%d%s", p.State.LastHash, proof.Timestamp.UnixNano(), transactionsHash)
    hash := sha256.New()
    _, writeErr := hash.Write([]byte(input))
    if writeErr != nil {
        return false, fmt.Errorf("failed to write hash: %w", writeErr)
    }
    expectedHash := hex.EncodeToString(hash.Sum(nil))

    // Step 3: Check if the calculated hash matches the proof's hash
    if proof.Hash != expectedHash {
        return false, fmt.Errorf("PoH proof validation failed: hash mismatch")
    }

    // Step 4: Ensure the sequence is correctly incremented
    if proof.Sequence != p.State.Sequence+1 {
        return false, fmt.Errorf("PoH proof validation failed: incorrect sequence (expected %d, got %d)", p.State.Sequence+1, proof.Sequence)
    }

    // Step 5: Update the PoH state if validation succeeds
    p.State.LastHash = proof.Hash
    p.State.LastTimestamp = proof.Timestamp
    p.State.Sequence = proof.Sequence

    log.Printf("[Success] PoH proof validated successfully: Sequence=%d, Timestamp=%s\n", proof.Sequence, proof.Timestamp.Format(time.RFC3339))
    return true, nil
}



// ValidatePoHTransaction validates transactions and integrates PoH proof generation and validation.
func (p *PoH) ValidatePoHTransaction(transactions []Transaction, validator string) (bool, error) {
    if len(transactions) == 0 {
        return false, fmt.Errorf("no transactions provided for PoH validation")
    }

    if validator == "" {
        return false, fmt.Errorf("validator ID is missing")
    }

    log.Printf("[Info] Starting transaction validation for PoH. Validator: %s\n", validator)

    // Step 1: Generate a PoH proof for the transactions
    proof, err := p.GeneratePoHProof(transactions)
    if err != nil {
        return false, fmt.Errorf("failed to generate PoH proof: %w", err)
    }

    // Step 2: Validate the PoH proof
    isValid, err := p.ValidatePoHProof(proof, transactions)
    if !isValid {
        return false, fmt.Errorf("PoH proof validation failed: %w", err)
    }

    // Step 3: Validate each transaction in the proof
    for _, tx := range transactions {
        validationKey := fmt.Sprintf("%s:%s", tx.TransactionType, tx.TransactionFunction)
        validationFunc, exists := p.ValidationMap[validationKey]
        if !exists {
            return false, fmt.Errorf("no validation logic found for key: %s in transaction %s", validationKey, tx.TransactionID)
        }

        // Validate the transaction using the mapped function
        if !validationFunc(tx) {
            return false, fmt.Errorf("validation failed for transaction %s using key %s", tx.TransactionID, validationKey)
        }
    }

    // Step 4: Reward the validator for participation
    participationTime := float64(proof.Timestamp.UnixNano() - p.State.LastTimestamp.UnixNano())
    err = p.RewardManager.DistributePoHRewards(validator, participationTime)
    if err != nil {
        return false, fmt.Errorf("failed to distribute rewards to validator %s: %w", validator, err)
    }

    log.Printf("[Success] All transactions validated successfully for PoH. Validator rewarded: %s\n", validator)
    return true, nil
}

// computeCrossChainTransactionHash computes a secure hash for cross-chain transaction metadata.
func computeCrossChainTransactionHash(tx CrossChainTransaction) (string, error) {
    // Validate transaction input
    if tx.TransactionID == "" || tx.FromChain == "" || tx.ToChain == "" {
        return "", fmt.Errorf("invalid transaction data: missing mandatory fields")
    }
    if tx.Amount <= 0 {
        return "", fmt.Errorf("invalid transaction amount: must be greater than 0")
    }

    // Prepare hash input
    hashInput := fmt.Sprintf("%s:%s:%s:%.2f:%s:%s:%s",
        tx.TransactionID, tx.FromChain, tx.ToChain, tx.Amount, tx.TokenSymbol, tx.FromAddress, tx.ToAddress)

    // Compute SHA-256 hash
    hash := sha256.New()
    _, err := hash.Write([]byte(hashInput))
    if err != nil {
        return "", fmt.Errorf("failed to compute hash: %w", err)
    }

    // Return the hexadecimal-encoded hash
    return hex.EncodeToString(hash.Sum(nil)), nil
}

// GenerateMultipleProofs generates a series of PoH proofs and stores them in the ledger.
func (p *PoH) GenerateMultipleProofs(numProofs int) ([]PoHProof, error) {
    if numProofs <= 0 {
        return nil, fmt.Errorf("invalid number of proofs: must be greater than 0")
    }

    proofs := make([]PoHProof, 0, numProofs)
    for i := 0; i < numProofs; i++ {
        // Generate the proof
        proof, err := p.GeneratePoHProof([]Transaction{}) // Pass actual transactions if applicable
        if err != nil {
            return nil, fmt.Errorf("failed to generate PoH proof at index %d: %w", i, err)
        }

        // Append to the list of proofs
        proofs = append(proofs, proof)

        // Log progress
        log.Printf("[Info] Generated PoH proof %d/%d: Sequence=%d, Timestamp=%s\n",
            i+1, numProofs, proof.Sequence, proof.Timestamp.Format(time.RFC3339))

        // Simulate a time gap between proofs (if required)
        time.Sleep(time.Millisecond * 10)
    }

    return proofs, nil
}

// computeAggregateHash aggregates a list of transaction hashes into a single SHA-256 hash.
func computeAggregateHash(transactionHashes []string) (string, error) {
    if len(transactionHashes) == 0 {
        return "", fmt.Errorf("no transaction hashes provided for aggregation")
    }

    // Concatenate all transaction hashes
    combined := strings.Join(transactionHashes, "")

    // Compute the aggregate SHA-256 hash
    hash := sha256.New()
    _, err := hash.Write([]byte(combined))
    if err != nil {
        return "", fmt.Errorf("failed to compute aggregate hash: %w", err)
    }

    return hex.EncodeToString(hash.Sum(nil)), nil
}


