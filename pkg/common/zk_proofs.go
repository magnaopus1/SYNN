package common

import (
	"errors"
	"fmt"
	"sync"
	"time"
	"synnergy_network/pkg/ledger"
	
)

// ZkProof represents a zero-knowledge proof used in the blockchain system
type ZkProof struct {
	ProofID        string                        // Unique identifier for the zk-proof
	ProverID       string                        // ID of the prover generating the proof
	VerifierID     string                        // ID of the verifier validating the proof
	ProofData      []byte                        // The actual zk-proof data
	IsValid        bool                          // Whether the proof has been validated
	VerifiedAt     time.Time                     // Time when the proof was verified
	Ledger         *ledger.Ledger                // Reference to the ledger for recording proof events
	Encryption     *Encryption        // Encryption service for securing proof data
	Consensus      *SynnergyConsensus // Consensus system for validating zk-proofs
	mu             sync.Mutex                    // Mutex for concurrency control
}

type ZKOracleData struct {
    OracleID    string    `json:"oracle_id"`
    DataFeedID  string    `json:"data_feed_id"`
    ZKProof     []byte    `json:"zk_proof"`  // Change to []byte
    DataPayload string    `json:"data_payload"`
    Verified    bool      `json:"verified"`
    Timestamp   time.Time `json:"timestamp"`
    HandlerNode string    `json:"handler_node"`
}


// NewZkProof initializes a new zero-knowledge proof
func NewZkProof(proofID, proverID, verifierID string, ledgerInstance *ledger.Ledger, encryptionService *Encryption, consensus *SynnergyConsensus) *ZkProof {
	return &ZkProof{
		ProofID:    proofID,
		ProverID:   proverID,
		VerifierID: verifierID,
		Ledger:     ledgerInstance,
		Encryption: encryptionService,
		Consensus:  consensus,
	}
}

// GenerateProof generates a new zk-proof based on input data
func (p *ZkProof) GenerateProof(inputData []byte) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	// Encrypt the input data to generate the zk-proof (use correct algorithm, e.g., "AES")
	encryptedData, err := p.Encryption.EncryptData("AES", inputData, EncryptionKey)  // Correctly reference EncryptionKey
	if err != nil {
		return fmt.Errorf("failed to encrypt input data for zk-proof: %v", err)
	}

	// Store the proof data
	p.ProofData = encryptedData

	// Convert time.Time to string (using RFC3339 format)
	timeStr := time.Now().Format(time.RFC3339)

	// Record the proof generation event in the ledger
	err = p.Ledger.CryptographyLedger.RecordProofGeneration(p.ProofID, p.ProverID, timeStr)  // Use formatted string for time
	if err != nil {
		return fmt.Errorf("failed to log proof generation: %v", err)
	}

	fmt.Printf("Zero-Knowledge Proof %s generated by prover %s\n", p.ProofID, p.ProverID)
	return nil
}


// VerifyProof verifies the zk-proof against the expected data and validates the proof.
func (p *ZkProof) VerifyProof(expectedData []byte) error {
	p.mu.Lock()
	defer p.mu.Unlock()

	// Decrypt the proof data for verification
	decryptedData, err := p.Encryption.DecryptData(p.ProofData, EncryptionKey)
	if err != nil {
		return fmt.Errorf("failed to decrypt zk-proof: %v", err)
	}

	// Compare decrypted data with the expected data to validate the proof
	if string(decryptedData) == string(expectedData) {
		p.IsValid = true
		p.VerifiedAt = time.Now()

		// Record proof validation in the ledger (pass only two arguments)
		err = p.Ledger.CryptographyLedger.RecordProofValidation(p.ProofID, p.VerifierID)
		if err != nil {
			return fmt.Errorf("failed to log proof validation: %v", err)
		}

		// Consensus validation after successful proof verification
		err = p.Consensus.ValidateZKProof(p.ProofID) // Ensure ValidateProof is implemented in SynnergyConsensus
		if err != nil {
			return fmt.Errorf("consensus validation failed for proof %s: %v", p.ProofID, err)
		}

		fmt.Printf("Zero-Knowledge Proof %s verified by verifier %s\n", p.ProofID, p.VerifierID)
	} else {
		return errors.New("zk-proof verification failed: data mismatch")
	}

	return nil
}


// RetrieveProof retrieves the zk-proof data for auditing or inspection
func (p *ZkProof) RetrieveProof() ([]byte, error) {
	p.mu.Lock()
	defer p.mu.Unlock()

	if p.ProofData == nil {
		return nil, errors.New("proof data not available")
	}

	fmt.Printf("zk-Proof %s retrieved for auditing\n", p.ProofID)
	return p.ProofData, nil
}

// IsProofValid checks if the zk-proof has been successfully validated
func (p *ZkProof) IsProofValid() bool {
	p.mu.Lock()
	defer p.mu.Unlock()

	return p.IsValid
}
